<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小工具_转换单词/变量</title>
      <link href="/zhuylin.github.io/2021/07/21/blog9_tool_changeWord/"/>
      <url>/zhuylin.github.io/2021/07/21/blog9_tool_changeWord/</url>
      
        <content type="html"><![CDATA[<p>可用于平时打代码转换某个变量，PS：不单是整个文件的变量更改，也可抽取部分段落的修改。当然，也可以用于word文档的一些单词的修改（后面将更新中文版）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">FileDesc = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Utility: Replace words among English documents or replace variables among codes</span></span><br><span class="line"><span class="string">    Author: LynnJute (1151030072@qq.com)</span></span><br><span class="line"><span class="string">    Website: lynnjute.top</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeWord_EN</span>(<span class="params">text, original_word, target_word</span>):</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    len1 = <span class="built_in">len</span>(original_word)</span><br><span class="line">    len2 = <span class="built_in">len</span>(target_word)</span><br><span class="line">    new_text = text</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        index = new_text.find(original_word, index)</span><br><span class="line">        <span class="keyword">if</span> index == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># the first word</span></span><br><span class="line">        front_index = index</span><br><span class="line">        <span class="keyword">if</span> index != <span class="number">0</span>:</span><br><span class="line">            front = new_text[index - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            front = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        back_index = (index + len1)</span><br><span class="line">        <span class="comment"># the last word</span></span><br><span class="line">        len_t = <span class="built_in">len</span>(new_text)</span><br><span class="line">        <span class="keyword">if</span> back_index &lt; len_t:</span><br><span class="line">            back = new_text[back_index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> front.isalpha() <span class="keyword">or</span> back.isalpha():</span><br><span class="line">            index += len1</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            index += <span class="number">13</span></span><br><span class="line">        ff = new_text[:front_index]</span><br><span class="line">        bb = new_text[back_index:]</span><br><span class="line">        new_text = ff + target_word + bb</span><br><span class="line">    <span class="keyword">return</span> new_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># Put the text in here</span></span><br><span class="line">    input_text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Input</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    dedent_text = textwrap.dedent(input_text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Put the word that you want to change</span></span><br><span class="line">    original_word = <span class="built_in">input</span>(<span class="string">&quot;Input the word you want to change:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Put the target word that you want to change to</span></span><br><span class="line">    target_word = <span class="built_in">input</span>(<span class="string">&quot;Input the target word that you want to change to:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># original text</span></span><br><span class="line">    <span class="comment"># print(dedent_text)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># target text</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nResult:\n&quot;</span>, changeWord_EN(dedent_text, original_word, target_word))</span><br></pre></td></tr></table></figure><p>注意：直接将要改的部分放进代码Input这个位置，运行代码后输入更改的词和要目标词。</p>]]></content>
      
      
      <categories>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX12_learning02_HLSL</title>
      <link href="/zhuylin.github.io/2021/07/18/blog8_directX2_hlsl/"/>
      <url>/zhuylin.github.io/2021/07/18/blog8_directX2_hlsl/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> DirectX12_learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> DirectX </tag>
            
            <tag> HLSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_learning01_Numpy</title>
      <link href="/zhuylin.github.io/2021/07/18/blog7_python1_numpy/"/>
      <url>/zhuylin.github.io/2021/07/18/blog7_python1_numpy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DirectX12_learning01_DirectX3D基础</title>
      <link href="/zhuylin.github.io/2021/05/14/blog6_directX1_basic/"/>
      <url>/zhuylin.github.io/2021/05/14/blog6_directX1_basic/</url>
      
        <content type="html"><![CDATA[<h2 id="Direct3D的初始化"><a href="#Direct3D的初始化" class="headerlink" title="Direct3D的初始化"></a>Direct3D的初始化</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="组件对象模型（COM）"><a href="#组件对象模型（COM）" class="headerlink" title="组件对象模型（COM）"></a>组件对象模型（COM）</h4><p>DX12使用COM编程组件，帮助隐藏大量底层细节。我们只需知道获取指向某COM接口的指针。在使用完某接口时便应调用它的Release方法，而不是用delete来删除，当COM对象引用计数为0时，它将自动释放自己占用的内存。</p><p>为了管理COM对象的生命周期，代码中大量使用<strong>ComPtr</strong>，它是<strong>指向COM的智能指针</strong>，当一个ComPtr实例超出作用域范围时，它会自动调用COM的Release方法。</p><p>常用的ComPtr方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ComPtr &lt;A&gt; ptr;<span class="comment">//定义一个ComPtr智能指针ptr</span></span><br><span class="line"></span><br><span class="line">ptr.<span class="built_in">Get</span>();  <span class="comment">//返回一个指向底层COM接口的指针</span></span><br><span class="line">ptr.<span class="built_in">GetAddressOf</span>();  <span class="comment">//返回指针的地址</span></span><br><span class="line">ptr.<span class="built_in">GetAddressOfAndRelease</span>();  <span class="comment">//返回地址并且减少引用</span></span><br><span class="line">ptr.<span class="built_in">Reset</span>();  <span class="comment">//将此ComPtr实例设置为nullptr并且释放与之相关的所有引用，同时减少其底层COM接口的引用计数</span></span><br></pre></td></tr></table></figure><h4 id="交换链和页面翻转"><a href="#交换链和页面翻转" class="headerlink" title="交换链和页面翻转"></a>交换链和页面翻转</h4><p>为了避免动画中出现画面闪烁的问题，最好将动画帧完整地绘制在后台缓冲区的离屏纹理内。此时需要由硬件管理的两种纹理缓冲区：前台缓冲区和后台缓冲区。<strong>前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被绘制在后台缓冲区里。当后台缓冲区的动画帧绘制完成之后，两种缓冲区的角色互换（该操作称为呈现，presenting）</strong>。呈现只需交换两个缓冲区的指针即可实现。前台缓冲区和后台缓冲区构成了交换链（swap chain），用IDXGISwapChain接口来表示。</p><h4 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h4><p>深度缓冲区也是一种纹理，常用的格式有：</p><ul><li>DXGI_FORMAT_D32_FLOAT_S8X24_UINT： 64位，其中32位指定浮点型深度缓冲区，8位（无符号）分配给模板缓冲区，剩下24位用于填充对其。</li><li>DXGI_FORMAT_D32_FLOAT：指定一个32位浮点型深度缓冲区。</li></ul><h4 id="资源与描述符"><a href="#资源与描述符" class="headerlink" title="资源与描述符"></a>资源与描述符</h4><p>在发出绘制命令之前，需将本次调用（draw call）相关的资源绑定（bind或称链接，link）到渲染流水线上。<strong>GPU资源并非直接与渲染流水线相绑定，而是通过描述符（descriptor）的对象来对它间接引用，这是一种轻量级结构。</strong>创建描述符的最佳时机为初始化期间，因为需一些类型检测和验证工作。</p><p>常用的描述符：</p><ul><li>CBV/SRV/UAV：常量缓冲区视图、着色器资源视图、无序访问视图。</li><li>采样器（sampler）：采样器资源，用于纹理贴图。</li><li>RTV：渲染目标视图资源（render target view）。</li><li>DSV：深度/模板视图资源（depth/stencil view）。</li></ul><h4 id="多重采样技术"><a href="#多重采样技术" class="headerlink" title="多重采样技术"></a>多重采样技术</h4><p>MSAA参考文章：</p><p>利用D3D进行多重采样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DXGI_SAMPLE_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">UINT Count;<span class="comment">//每个像素的采样次数</span></span><br><span class="line">UINT Quality;<span class="comment">//用户期望的图像质量级别</span></span><br><span class="line">&#125; DXGI_SAMPLE_DESC;</span><br></pre></td></tr></table></figure><p>如果不希望使用多重采样，则可以将采样数量设置为1，质量级别为0。</p><p>注意：当创建后台缓冲区和深度缓冲区时，多重采样的有关设置一定要相同。</p><h3 id="CPU与GPU间的交互"><a href="#CPU与GPU间的交互" class="headerlink" title="CPU与GPU间的交互"></a>CPU与GPU间的交互</h3><p>为了获得最佳性能，最好的情况是让两者尽量同时工作，少同步。</p><h4 id="命令队列和命令列表"><a href="#命令队列和命令列表" class="headerlink" title="命令队列和命令列表"></a>命令队列和命令列表</h4><p>每个GPU都至少维护者一个命令队列（本质上是环形缓冲区），CPU可利用命令列表将命令提交到命令队列中去。下图为命令队列：</p><p><a href="https://imgtu.com/i/gsyf3T"><img src="https://z3.ax1x.com/2021/05/14/gsyf3T.jpg" alt="gsyf3T.jpg" border="0" width = "30%" /></a></p><p>D3D12中命令队列被抽象为ID3D12CommandQueue接口来表示。用ExecuteCommandLists方法可将命令列表里的命令添加到命令队列之中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ID3D12CommandQueue::ExcuteCommandQueue</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//命令列表数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT Count,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//待执行的命令列表数组，指向命令列表数组中第一个元素的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">ID3D12CommandList *<span class="keyword">const</span> *ppCommandLists</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="CPU与GPU间的同步"><a href="#CPU与GPU间的同步" class="headerlink" title="CPU与GPU间的同步"></a><span id="jump">CPU与GPU间的同步</span></h4><p>一种方法是强制CPU等待，直到GPU完成所有命令的处理，达到某个指定的围栏点（fance point）为止。这种方法称为刷新命令队列，可以通过围栏来实现。围栏用ID3D12Fence接口表示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">ID3D12Device::CreateFence</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">UINT InitalValue,<span class="comment">//标识围栏点</span></span></span></span><br><span class="line"><span class="params"><span class="function">D3D12_FENCE_FLAGS Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">REFIID riid,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> **ppFence</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>实现同步（用围栏刷新命令队列）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UINT64 mCurrentFence = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">D3DApp::FlushCommandQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//增加围栏值，接下来将命令标记到此围栏点</span></span><br><span class="line">mCurrentFence++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向命令队列中添加一条用来设置新围栏点的命令</span></span><br><span class="line"><span class="built_in">ThrowIfFailed</span>(mCommandQueue-&gt;<span class="built_in">Signal</span>(mFence.<span class="built_in">Get</span>(), mCurrentFence));</span><br><span class="line"></span><br><span class="line"><span class="comment">//在CPU端等待GPU，直到后者执行完这个围栏点之前的所有命令</span></span><br><span class="line"><span class="keyword">if</span> (mFence-&gt;<span class="built_in">GetCompletedValue</span>() &lt; mCurrentFence)</span><br><span class="line">&#123;</span><br><span class="line">HANDLE eventHandle = <span class="built_in">CreateEventEx</span>(<span class="literal">nullptr</span>, <span class="literal">false</span>, <span class="literal">false</span>, EVENT_ALL_ACCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若GPU命中此前的围栏（即执行到Signal()指令，修改了围栏值），则激发预定事件</span></span><br><span class="line"><span class="built_in">ThrowFailed</span>(mFence-&gt;<span class="built_in">SetEventOnCompletion</span>(mCurrentFence, eventHandle));</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待GPU命中围栏，激发事件</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(eventHandle, INFINITE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(eventHandle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化Direct3D"><a href="#初始化Direct3D" class="headerlink" title="初始化Direct3D"></a><strong>初始化Direct3D</strong></h3><p>Direct3D初始化的过程可以分为以下步骤：</p><ol><li>创建设备</li><li>创建围栏</li><li>获取描述符大小</li><li>设置MSAA抗锯齿属性</li><li>创建命令队列和命令列表</li><li>创建交换链</li><li>创建描述符堆</li><li>创建渲染目标视图</li><li>创建深度/模板缓冲区及其视图</li><li>实现CPU和GPU同步</li><li> 设置视口和裁剪矩形</li></ol><h4 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h4><p>设备是通过DXGI API的IDXGIFactory接口来创建的。所以我们先要CreateDXGIFactory，然后再CreateDevice。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComPtr&lt;IDXGIFactory4&gt; dxgiFactory;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(<span class="built_in">CreateDXGIFactory1</span>(<span class="built_in">IID_PPV_ARGS</span>(&amp;dxgiFactory)));</span><br><span class="line">    mdxgiFactory-&gt;<span class="built_in">EnumWarpAdapter</span>(<span class="built_in">IID_PPV_ARGS</span>(&amp;pWarpAdapter)); <span class="comment">//枚举WARP适配器</span></span><br><span class="line">    </span><br><span class="line">    ComPtr&lt;ID3D12Device&gt; d3dDevice;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(<span class="built_in">D3D12CreateDevice</span>(<span class="literal">nullptr</span>, <span class="comment">//此参数如果设置为nullptr，则使用主适配器</span></span><br><span class="line">D3D_FEATURE_LEVEL_12_0,<span class="comment">//应用程序需要硬件所支持的最低功能级别</span></span><br><span class="line"><span class="built_in">IID_PPV_ARGS</span>(&amp;d3dDevice)));<span class="comment">//返回所建设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建围栏"><a href="#创建围栏" class="headerlink" title="创建围栏"></a>创建围栏</h4><p>通过设备创建围栏，以便之后同步CPU和GPU</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateFence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComPtr&lt;ID3D12Fence&gt; fence;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(d3dDevice-&gt;<span class="built_in">CreateFence</span>(<span class="number">0</span>, D3D12_FENCE_FLAG_NONE, <span class="built_in">IID_PPV_ARGS</span>(&amp;fence)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取描述符大小"><a href="#获取描述符大小" class="headerlink" title="获取描述符大小"></a>获取描述符大小</h4><p>这个大小可以让我们知道描述符堆中每个元素的大小（描述符在不同的GPU平台上的大小各异），方便我们之后在地址中做偏移来找到堆中的描述符元素。这里我们获取三个描述符大小，分别是RTV（渲染目标缓冲区描述符）、DSV（深度模板缓冲区描述符）、CBV_SRV_UAV（常量缓冲区描述符、着色器资源缓冲描述符和随机访问缓冲描述符）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetDescriptorSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT rtvDescriptorSize = d3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);</span><br><span class="line">    UINT dsvDescriptorSize = d3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);</span><br><span class="line">    UINT cbv_srv_uavDescriptorSize = d3dDevice-&gt;<span class="built_in">GetDescriptorHandleIncrementSize</span>(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置MSAA抗锯齿属性"><a href="#设置MSAA抗锯齿属性" class="headerlink" title="设置MSAA抗锯齿属性"></a>设置MSAA抗锯齿属性</h4><p>先填充多重采样属性结构体，然后通过CheckFeatureSupport函数设置NumQualityLevels。注意：此处不使用MSAA，采样数量设置为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetMSAA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msaaQualityLevels;</span><br><span class="line">    msaaQualityLevels.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<span class="comment">//UNORM是归一化处理的无符号整数</span></span><br><span class="line">    msaaQualityLevels.SampleCount = <span class="number">1</span>;</span><br><span class="line">    msaaQualityLevels.Flags = D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE;</span><br><span class="line">    msaaQualityLevels.NumQualityLevels = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前图形驱动对MSAA多重采样的支持（注意：第二个参数即是输入又是输出）</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(d3dDevice-&gt;<span class="built_in">CheckFeatureSupport</span>(D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS, &amp;msaaQualityLevels, <span class="built_in"><span class="keyword">sizeof</span></span>(msaaQualityLevels)));</span><br><span class="line">    <span class="comment">//NumQualityLevels在Check函数里会进行设置</span></span><br><span class="line">    <span class="comment">//如果支持MSAA，则Check函数返回的NumQualityLevels &gt; 0</span></span><br><span class="line">    <span class="comment">//expression为假（即为0），则终止程序运行，并打印一条出错信息</span></span><br><span class="line">    <span class="built_in">assert</span>(msaaQualityLevels.NumQualityLevels &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建命令队列和命令列表"><a href="#创建命令队列和命令列表" class="headerlink" title="创建命令队列和命令列表"></a>创建命令队列和命令列表</h4><p>创建命令队列、命令列表和命令分配器。他们三者的关系是：首先CPU创建命令列表，然后将关联在命令分配器上的命令传入命令列表，最后将命令列表传入命令队列给GPU处理。这一步只是做了三者的创建工作。注意，我们在初始化D3D12_COMMAND_QUEUE_DESC时，只初始化了两项，其他两项我们在大括号中默认初始化了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateCommandObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D3D12_COMMAND_QUEUE_DESC commandQueueDesc = &#123;&#125;;</span><br><span class="line">    commandQueueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;</span><br><span class="line">    commandQueueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;</span><br><span class="line">    ComPtr&lt;ID3D12CommandQueue&gt; cmdQueue;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(d3dDevice-&gt;<span class="built_in">CreateCommandQueue</span>(&amp;commandQueueDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;cmdQueue)));</span><br><span class="line">    ComPtr&lt;ID3D12CommandAllocator&gt; cmdAllocator;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(d3dDevice-&gt;<span class="built_in">CreateCommandAllocator</span>(D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="built_in">IID_PPV_ARGS</span>(&amp;cmdAllocator)));<span class="comment">//&amp;cmdAllocator等价于cmdAllocator.GetAddressOf</span></span><br><span class="line">    ComPtr&lt;ID3D12GraphicsCommandList&gt; cmdList;<span class="comment">//注意此处的接口名是ID3D12GraphicsCommandList，而不是ID3D12CommandList</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(d3dDevice-&gt;<span class="built_in">CreateCommandList</span>(<span class="number">0</span>, <span class="comment">//掩码值为0，单GPU</span></span><br><span class="line">D3D12_COMMAND_LIST_TYPE_DIRECT, <span class="comment">//命令列表类型</span></span><br><span class="line">cmdAllocator.<span class="built_in">Get</span>(),<span class="comment">//命令分配器接口指针</span></span><br><span class="line"><span class="literal">nullptr</span>,<span class="comment">//流水线状态对象PSO，这里不绘制，所以空指针</span></span><br><span class="line"><span class="built_in">IID_PPV_ARGS</span>(&amp;cmdList)));<span class="comment">//返回创建的命令列表</span></span><br><span class="line">    cmdList-&gt;<span class="built_in">Close</span>();<span class="comment">//重置命令列表前必须将其关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建交换链"><a href="#创建交换链" class="headerlink" title="创建交换链"></a>创建交换链</h4><p>交换链中存着渲染目标资源，即后台缓冲区资源。我们通过上文中提到过的DXGI API下的IDXGIFactory接口来创建交换链。这里我们还是禁用MSAA多重采样。因为其设置比较麻烦，这里直接设置MSAA会出错，所以count还是为1，质量为0。还要注意一点，CreateSwapChain函数的第一个参数其实是命令队列接口指针，不是设备接口指针，参数描述有误导。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ComPtr&lt;IDXGISwapChain&gt; swapChain;</span><br><span class="line">    swapChain.<span class="built_in">Reset</span>();</span><br><span class="line">    DXGI_SWAP_CHAIN_DESC swapChainDesc;<span class="comment">//交换链描述结构体</span></span><br><span class="line">    swapChainDesc.BufferDesc.Width = <span class="number">1280</span>;<span class="comment">//缓冲区分辨率的宽度</span></span><br><span class="line">    swapChainDesc.BufferDesc.Height = <span class="number">720</span>;<span class="comment">//缓冲区分辨率的高度</span></span><br><span class="line">    swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;<span class="comment">//缓冲区的显示格式</span></span><br><span class="line">    swapChainDesc.BufferDesc.RefreshRate.Denominator = <span class="number">1</span>;<span class="comment">//刷新率的分子</span></span><br><span class="line">    swapChainDesc.BufferDesc.RefreshRate.Numerator = <span class="number">60</span>;<span class="comment">//刷新率的分母</span></span><br><span class="line">    swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;<span class="comment">//逐行扫描VS隔行扫描(未指定的)</span></span><br><span class="line">    swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;<span class="comment">//图像相对屏幕的拉伸（未指定的）</span></span><br><span class="line">    swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;<span class="comment">//将数据渲染至后台缓冲区（即作为渲染目标）</span></span><br><span class="line">    swapChainDesc.OutputWindow = mhMainWnd;<span class="comment">//渲染窗口句柄</span></span><br><span class="line">    swapChainDesc.SampleDesc.Count = <span class="number">1</span>;<span class="comment">//多重采样数量</span></span><br><span class="line">    swapChainDesc.SampleDesc.Quality = <span class="number">0</span>;<span class="comment">//多重采样质量</span></span><br><span class="line">    swapChainDesc.Windowed = <span class="literal">true</span>;<span class="comment">//是否窗口化</span></span><br><span class="line">    swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;<span class="comment">//固定写法</span></span><br><span class="line">    swapChainDesc.BufferCount = <span class="number">2</span>;<span class="comment">//后台缓冲区数量（双缓冲）</span></span><br><span class="line">    swapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;<span class="comment">//自适应窗口模式（自动选择最适于当前窗口尺寸的显示模式）</span></span><br><span class="line">    <span class="comment">//利用DXGI接口下的工厂类创建交换链</span></span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(dxgiFactory-&gt;<span class="built_in">CreateSwapChain</span>(cmdQueue.<span class="built_in">Get</span>(), &amp;swapChainDesc, swapChain.<span class="built_in">GetAddressOf</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建描述符堆"><a href="#创建描述符堆" class="headerlink" title="创建描述符堆"></a>创建描述符堆</h4><p>描述符堆是存放描述符的一段连续内存空间。因为是双后台缓冲，所以我们要创建存放2个RTV的RTV堆，而深度模板缓存只有一个，所以创建1个DSV的DSV堆。具体过程是，先填充描述符堆属性结构体，然后通过设备创建描述符堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDescriptorHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//首先创建RTV堆</span></span><br><span class="line">    D3D12_DESCRIPTOR_HEAP_DESC rtvDescriptorHeapDesc;</span><br><span class="line">    rtvDescriptorHeapDesc.NumDescriptors = <span class="number">2</span>;</span><br><span class="line">    rtvDescriptorHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line">    rtvDescriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;</span><br><span class="line">    rtvDescriptorHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">    ComPtr&lt;ID3D12DescriptorHeap&gt; rtvHeap;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(d3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(&amp;rtvDescriptorHeapDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;rtvHeap)));</span><br><span class="line">    <span class="comment">//然后创建DSV堆</span></span><br><span class="line">    D3D12_DESCRIPTOR_HEAP_DESC dsvDescriptorHeapDesc;</span><br><span class="line">    dsvDescriptorHeapDesc.NumDescriptors = <span class="number">1</span>;</span><br><span class="line">    dsvDescriptorHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;</span><br><span class="line">    dsvDescriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;</span><br><span class="line">    dsvDescriptorHeapDesc.NodeMask = <span class="number">0</span>;</span><br><span class="line">    ComPtr&lt;ID3D12DescriptorHeap&gt; dsvHeap;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(d3dDevice-&gt;<span class="built_in">CreateDescriptorHeap</span>(&amp;dsvDescriptorHeapDesc, <span class="built_in">IID_PPV_ARGS</span>(&amp;dsvHeap)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建渲染目标视图"><a href="#创建渲染目标视图" class="headerlink" title="创建渲染目标视图"></a>创建渲染目标视图</h4><p>有了描述符堆之后，我们就可以创建堆中的描述符了，我们首先创建RTV。具体过程是，先从RTV堆中拿到首个RTV句柄，然后获得存于交换链中的RT资源，最后创建RTV将RT资源和RTV句柄联系起来，并在最后根据RTV大小做了在堆中的地址偏移。</p><p>注意这里用到了CD3DX12_CPU_DESCRIPTOR_HANDL，这个变体在d3dx12.h头文件中定义，DX库并没有集成，需要我们自行下载。这里的CD3DX12_CPU_DESCRIPTOR_HANDLE是个变体类，它的构造函数初始化了D3D12_CPU_DESCRIPTOR_HANDLE结构体中的元素，所以直接调用其构造函数即可。之后我们会经常用到CD3DX12开头的变体类来简化初始化的代码书写，用法和作用基本一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateRTV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CD3DX12_CPU_DESCRIPTOR_HANDLE <span class="title">rtvHeapHandle</span><span class="params">(rtvHeap-&gt;GetCPUDescriptorHandleForHeapStart())</span></span>;</span><br><span class="line">    ComPtr&lt;ID3D12Resource&gt; swapChainBuffer[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//获得存于交换链中的后台缓冲区资源</span></span><br><span class="line">swapChain-&gt;<span class="built_in">GetBuffer</span>(i, <span class="built_in">IID_PPV_ARGS</span>(swapChainBuffer[i].<span class="built_in">GetAddressOf</span>()));</span><br><span class="line"><span class="comment">//创建RTV</span></span><br><span class="line">d3dDevice-&gt;<span class="built_in">CreateRenderTargetView</span>(swapChainBuffer[i].<span class="built_in">Get</span>(),</span><br><span class="line">    <span class="literal">nullptr</span>,<span class="comment">//在交换链创建中已经定义了该资源的数据格式，所以这里指定为空指针</span></span><br><span class="line">    rtvHeapHandle);<span class="comment">//描述符句柄结构体（这里是变体，继承自CD3DX12_CPU_DESCRIPTOR_HANDLE）</span></span><br><span class="line"><span class="comment">//偏移到描述符堆中的下一个缓冲区</span></span><br><span class="line">rtvHeapHandle.<span class="built_in">Offset</span>(<span class="number">1</span>, rtvDescriptorSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建深度-模板缓冲区及其视图"><a href="#创建深度-模板缓冲区及其视图" class="headerlink" title="创建深度/模板缓冲区及其视图"></a>创建深度/模板缓冲区及其视图</h4><p>创建完RTV后，我们就要创建DSV了。具体过程是，先在CPU中创建好DS资源，然后通过CreateCommittedResource函数将DS资源提交至GPU显存中，最后创建DSV将显存中的DS资源和DSV句柄联系起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDSV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在CPU中创建好深度模板数据资源</span></span><br><span class="line">    D3D12_RESOURCE_DESC dsvResourceDesc;</span><br><span class="line">    dsvResourceDesc.Alignment = <span class="number">0</span>;<span class="comment">//指定对齐</span></span><br><span class="line">    dsvResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;<span class="comment">//指定资源维度（类型）为TEXTURE2D</span></span><br><span class="line">    dsvResourceDesc.DepthOrArraySize = <span class="number">1</span>;<span class="comment">//纹理深度为1</span></span><br><span class="line">    dsvResourceDesc.Width = <span class="number">1280</span>;<span class="comment">//资源宽</span></span><br><span class="line">    dsvResourceDesc.Height = <span class="number">720</span>;<span class="comment">//资源高</span></span><br><span class="line">    dsvResourceDesc.MipLevels = <span class="number">1</span>;<span class="comment">//MIPMAP层级数量</span></span><br><span class="line">    dsvResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;<span class="comment">//指定纹理布局（这里不指定）</span></span><br><span class="line">    dsvResourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;<span class="comment">//深度模板资源的Flag</span></span><br><span class="line">    dsvResourceDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;<span class="comment">//24位深度，8位模板,还有个无类型的格式DXGI_FORMAT_R24G8_TYPELESS也可以使用</span></span><br><span class="line">    dsvResourceDesc.SampleDesc.Count = <span class="number">4</span>;<span class="comment">//多重采样数量</span></span><br><span class="line">    dsvResourceDesc.SampleDesc.Quality = msaaQualityLevels.NumQualityLevels - <span class="number">1</span>;<span class="comment">//多重采样质量</span></span><br><span class="line">    CD3DX12_CLEAR_VALUE optClear;<span class="comment">//清除资源的优化值，提高清除操作的执行速度（CreateCommittedResource函数中传入）</span></span><br><span class="line">    optClear.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;<span class="comment">//24位深度，8位模板,还有个无类型的格式DXGI_FORMAT_R24G8_TYPELESS也可以使用</span></span><br><span class="line">    optClear.DepthStencil.Depth = <span class="number">1</span>;<span class="comment">//初始深度值为1</span></span><br><span class="line">    optClear.DepthStencil.Stencil = <span class="number">0</span>;<span class="comment">//初始模板值为0</span></span><br><span class="line">    <span class="comment">//创建一个资源和一个堆，并将资源提交至堆中（将深度模板数据提交至GPU显存中）</span></span><br><span class="line">    ComPtr&lt;ID3D12Resource&gt; depthStencilBuffer;</span><br><span class="line">    <span class="built_in">ThrowIfFailed</span>(d3dDevice-&gt;<span class="built_in">CreateCommittedResource</span>(&amp;<span class="built_in">CD3DX12_HEAP_PROPERTIES</span>(D3D12_HEAP_TYPE_DEFAULT),<span class="comment">//堆类型为默认堆（不能写入）</span></span><br><span class="line">D3D12_HEAP_FLAG_NONE,<span class="comment">//Flag</span></span><br><span class="line">&amp;dsvResourceDesc,<span class="comment">//上面定义的DSV资源指针</span></span><br><span class="line">D3D12_RESOURCE_STATE_COMMON,<span class="comment">//资源的状态为初始状态</span></span><br><span class="line">&amp;optClear,<span class="comment">//上面定义的优化值指针</span></span><br><span class="line"><span class="built_in">IID_PPV_ARGS</span>(&amp;depthStencilBuffer)));<span class="comment">//返回深度模板资源</span></span><br><span class="line">    <span class="comment">//创建DSV(必须填充DSV属性结构体，和创建RTV不同，RTV是通过句柄)</span></span><br><span class="line">    <span class="comment">//D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc;</span></span><br><span class="line">    <span class="comment">//dsvDesc.Flags = D3D12_DSV_FLAG_NONE;</span></span><br><span class="line">    <span class="comment">//dsvDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;</span></span><br><span class="line">    <span class="comment">//dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;</span></span><br><span class="line">    <span class="comment">//dsvDesc.Texture2D.MipSlice = 0;</span></span><br><span class="line">    d3dDevice-&gt;<span class="built_in">CreateDepthStencilView</span>(depthStencilBuffer.<span class="built_in">Get</span>(),</span><br><span class="line"><span class="literal">nullptr</span>,<span class="comment">//D3D12_DEPTH_STENCIL_VIEW_DESC类型指针，可填&amp;dsvDesc（见上注释代码），</span></span><br><span class="line">                        <span class="comment">//由于在创建深度模板资源时已经定义深度模板数据属性，所以这里可以指定为空指针</span></span><br><span class="line">dsvHeap-&gt;<span class="built_in">GetCPUDescriptorHandleForHeapStart</span>());<span class="comment">//DSV句柄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完描述符后，我们需要标记DS资源的状态。为什么要标记呢？因为资源在不同的时间段有着不同的作用，比如，有时候它是只读，有时候又是可写入的。我们用ResourceBarrier下的Transition函数来转换资源状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmdList-&gt;<span class="built_in">ResourceBarrier</span>(<span class="number">1</span>,<span class="comment">//Barrier屏障个数</span></span><br><span class="line">&amp;CD3DX12_RESOURCE_BARRIER::<span class="built_in">Transition</span>(depthStencilBuffer.<span class="built_in">Get</span>(), </span><br><span class="line">D3D12_RESOURCE_STATE_COMMON,<span class="comment">//转换前状态（创建时的状态，即CreateCommittedResource函数中定义的状态）</span></span><br><span class="line">D3D12_RESOURCE_STATE_DEPTH_WRITE));<span class="comment">//转换后状态为可写入的深度图，还有一个D3D12_RESOURCE_STATE_DEPTH_READ是只可读的深度图</span></span><br></pre></td></tr></table></figure><p>等所有命令都进入cmdList后，还需要用ExecuteCommandLists函数，将命令从命令列表传入命令队列，也就是从CPU传入GPU的过程。注意：在传入命令队列前必须关闭命令列表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ThrowIfFailed</span>(cmdList-&gt;<span class="built_in">Close</span>());<span class="comment">//命令添加完后将其关闭</span></span><br><span class="line">ID3D12CommandList* cmdLists[] = &#123; cmdList.<span class="built_in">Get</span>() &#125;;<span class="comment">//声明并定义命令列表数组</span></span><br><span class="line">cmdQueue-&gt;<span class="built_in">ExecuteCommandLists</span>(_countof(cmdLists), cmdLists);<span class="comment">//将命令从命令列表传至命令队列</span></span><br></pre></td></tr></table></figure><h4 id="实现CPU和GPU同步"><a href="#实现CPU和GPU同步" class="headerlink" title="实现CPU和GPU同步"></a>实现CPU和GPU同步</h4><p>实现同步参考上面的“<a href="#jump">CPU与GPU间的同步</a>”内容。</p><h4 id="设置视口和裁剪矩形"><a href="#设置视口和裁剪矩形" class="headerlink" title="设置视口和裁剪矩形"></a>设置视口和裁剪矩形</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateViewPortAndScissorRect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D3D12_VIEWPORT viewPort;</span><br><span class="line">    D3D12_RECT scissorRect;</span><br><span class="line">    <span class="comment">//视口设置</span></span><br><span class="line">    viewPort.TopLeftX = <span class="number">0</span>;</span><br><span class="line">    viewPort.TopLeftY = <span class="number">0</span>;</span><br><span class="line">    viewPort.Width = <span class="number">1280</span>;</span><br><span class="line">    viewPort.Height = <span class="number">720</span>;</span><br><span class="line">    viewPort.MaxDepth = <span class="number">1.0f</span>;</span><br><span class="line">    viewPort.MinDepth = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">//裁剪矩形设置（矩形外的像素都将被剔除）</span></span><br><span class="line">    <span class="comment">//前两个为左上点坐标，后两个为右下点坐标</span></span><br><span class="line">    scissorRect.left = <span class="number">0</span>;</span><br><span class="line">    scissorRect.top = <span class="number">0</span>;</span><br><span class="line">    scissorRect.right = <span class="number">1280</span>;</span><br><span class="line">    scissorRect.bottom = <span class="number">720</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计时与动画"><a href="#计时与动画" class="headerlink" title="计时与动画"></a>计时与动画</h3><p><strong>参考文章</strong>：<br>    - DirectX 12 3D游戏开发实践（龙书）<br>    - <a href="https://zhuanlan.zhihu.com/p/129665235">https://zhuanlan.zhihu.com/p/129665235</a></p>]]></content>
      
      
      <categories>
          
          <category> DirectX12_learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> DirectX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法_动态规划</title>
      <link href="/zhuylin.github.io/2021/05/14/blog5_dp/"/>
      <url>/zhuylin.github.io/2021/05/14/blog5_dp/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAMES202_实时阴影（Real-Time Shadow）</title>
      <link href="/zhuylin.github.io/2021/05/12/blog4_GAMES202_shadow/"/>
      <url>/zhuylin.github.io/2021/05/12/blog4_GAMES202_shadow/</url>
      
        <content type="html"><![CDATA[<h3 id="一、阴影贴图（Shadow-Mapping）"><a href="#一、阴影贴图（Shadow-Mapping）" class="headerlink" title="一、阴影贴图（Shadow Mapping）"></a>一、阴影贴图（Shadow Mapping）</h3><h4 id="1-1-阴影贴图实现步骤："><a href="#1-1-阴影贴图实现步骤：" class="headerlink" title="1.1 阴影贴图实现步骤："></a>1.1 阴影贴图实现步骤：</h4><p>Pass-1：将光源视为相机，先进行一次渲染（这次渲染只保存深度信息，不进行着色），每个像素记录距离光源的最小深度，渲染结束后得到一张深度图，即为Shadow Map。<br>Pass-2：从原始相机位置出发渲染整个场景，将所有摄像机视角可见点，利用光源视角下的那一套投影矩阵，重新投影回光源，得到光源视角下的屏幕坐标，找到该屏幕坐标在Buffer上的深度值。</p><ul><li>如果该点在Buffer上的深度值与投影回光源的点的实际深度值相等，则说明此点可被光源照射，因此不在阴影中。</li><li>如果该点在Buffer上的深度值小于投影回光源的点的实际深度值，则说明此点不可被光源看见，即该点前方有物体遮挡，因此在阴影中。<br>在阴影中的点就不用计算Blinn-Phong中的<strong>镜面反射项</strong>和<strong>漫反射项</strong>。</li></ul><h4 id="1-2-阴影贴图缺点："><a href="#1-2-阴影贴图缺点：" class="headerlink" title="1.2 阴影贴图缺点："></a>1.2 阴影贴图缺点：</h4><ul><li>浮点数难以判断相等，易产生<strong>阴影斑块</strong>（即<strong>伪影</strong>，由深度测试期间的舍入误差引起的，解决方法是计算Z缓冲区时将像素稍微移向光源，后面再移回原位，或者设置偏移值）。</li><li>shadow maps查询时不采用双线性插值，只寻找最近的点，因为倘若插值发生在物体边缘时，与邻接点的深度差距很大，会导致插值结果会有很大的误差。</li><li>属于硬阴影，只适用于点光源</li><li><strong>阴影会出现锯齿</strong>，因为shadow map分辨率有限，存在走样问题，根本原因就在于shadow map的采样率不足。</li></ul><h4 id="1-3-阴影贴图实现代码"><a href="#1-3-阴影贴图实现代码" class="headerlink" title="1.3 阴影贴图实现代码"></a>1.3 阴影贴图实现代码</h4><h5 id="1-3-1-将相机放置到光源处"><a href="#1-3-1-将相机放置到光源处" class="headerlink" title="1.3.1 将相机放置到光源处"></a>1.3.1 将相机放置到光源处</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">CalcLightMVP</span>(<span class="params">translate, scale</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lightMVP = mat4.create();</span><br><span class="line">    <span class="keyword">let</span> modelMatrix = mat4.create();</span><br><span class="line">    <span class="keyword">let</span> viewMatrix = mat4.create();</span><br><span class="line">    <span class="keyword">let</span> projectionMatrix = mat4.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Model transform</span></span><br><span class="line">    mat4.translate(modelMatrix, modelMatrix, translate); <span class="comment">//先平移</span></span><br><span class="line">    mat4.scale(modelMatrix, modelMatrix, scale); <span class="comment">//后缩放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// View transform</span></span><br><span class="line">    mat4.lookAt(viewMatrix, <span class="built_in">this</span>.lightPos, <span class="built_in">this</span>.focalPoint, <span class="built_in">this</span>.lightUp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Projection transform</span></span><br><span class="line">    mat4.ortho(projectionMatrix, -<span class="number">500</span>, <span class="number">500</span>, -<span class="number">500</span>, <span class="number">500</span>, <span class="number">0.1</span>, <span class="number">1000</span>); <span class="comment">//正交投影</span></span><br><span class="line"></span><br><span class="line">    mat4.multiply(lightMVP, projectionMatrix, viewMatrix);</span><br><span class="line">    mat4.multiply(lightMVP, lightMVP, modelMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lightMVP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-2-使用shadowmap"><a href="#1-3-2-使用shadowmap" class="headerlink" title="1.3.2 使用shadowmap"></a>1.3.2 使用shadowmap</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float <span class="function"><span class="title">useShadowMap</span>(<span class="params">sampler2D shadowMap, vec4 shadowCoord</span>)</span>&#123;</span><br><span class="line">  float bias = Bias();</span><br><span class="line">  vec4 depth_raw = texture2D(shadowMap, shadowCoord.xy);</span><br><span class="line">  float depth_decode = unpack(depth_raw);</span><br><span class="line">  <span class="comment">//检查当前片段是否在阴影中</span></span><br><span class="line">  <span class="keyword">if</span> (depth_decode &gt; shadowCoord.z - bias) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-3-设置偏移值"><a href="#1-3-3-设置偏移值" class="headerlink" title="1.3.3 设置偏移值"></a>1.3.3 设置偏移值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float <span class="function"><span class="title">Bias</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  vec3 lightDir = normalize(uLightPos);</span><br><span class="line">  vec3 normal = normalize(vNormal);</span><br><span class="line">  float bias = max(<span class="number">0.005</span> * (<span class="number">1.0</span> - dot(normal, lightDir)), <span class="number">0.005</span>);</span><br><span class="line">  <span class="keyword">return</span> bias;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-阴影贴图背后的数学原理"><a href="#1-4-阴影贴图背后的数学原理" class="headerlink" title="1.4 阴影贴图背后的数学原理"></a>1.4 阴影贴图背后的数学原理</h4><h4 id="二、软阴影"><a href="#二、软阴影" class="headerlink" title="二、软阴影"></a>二、软阴影</h4><h4 id="三、基础Filtering技术"><a href="#三、基础Filtering技术" class="headerlink" title="三、基础Filtering技术"></a>三、基础Filtering技术</h4>]]></content>
      
      
      <categories>
          
          <category> GAMES202 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>棋盘渲染（Checkboard Rendering）</title>
      <link href="/zhuylin.github.io/2021/05/12/blog3_checkboardRendering/"/>
      <url>/zhuylin.github.io/2021/05/12/blog3_checkboardRendering/</url>
      
        <content type="html"><![CDATA[<p>棋盘渲染是一种生成全分辨率像素的技术，可大幅减少阴影，且对视觉质量影响最小。棋盘渲染与现代的抗锯齿后处理方法完全兼容，并且可以在前向和延迟渲染管道中实施。</p><h4 id="技术概述"><a href="#技术概述" class="headerlink" title="技术概述"></a>技术概述</h4><p><strong>参考文章</strong>：</p><ul><li><a href="https://software.intel.com/content/www/cn/zh/develop/articles/checkerboard-rendering-for-real-time-upscaling-on-intel-integrated-graphics.html">https://software.intel.com/content/www/cn/zh/develop/articles/checkerboard-rendering-for-real-time-upscaling-on-intel-integrated-graphics.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学面试准备</title>
      <link href="/zhuylin.github.io/2021/05/11/blog2_tuxingxuemianshi/"/>
      <url>/zhuylin.github.io/2021/05/11/blog2_tuxingxuemianshi/</url>
      
        <content type="html"><![CDATA[<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ol><li><p>点积和叉乘的作用</p><ul><li>点积：求解两向量的夹角，判断两向量是否正交或平行。</li><li>叉乘：计算一面的外向法向量，判断向量在另一个向量的左侧还是右侧，判断点是否在三角形内（方法：求点和每个顶点的向量，求逆时针或顺时针的边向量，向量叉乘的方向一致则在三角形内）。叉乘为0则在边上。判断凹凸。</li></ul></li><li><p>判断点是否在三角形内？</p><ul><li>利用叉积，求顺时针或逆时针的三角形边的向量，然后求点到三角形顶点的三个向量，然后两两求叉积，如果叉乘结果的向量方向一致则在三角形内，有一个叉乘为0则在边上。</li><li>用三角形重心坐标表示点，如果系数都是非负则表示在三角形内。</li></ul></li><li><p>判断多边形是凹多边形还是凸多边形<br> 取点集，计算各个向量，相邻边叉积，若有正有负，则为凹，否则为凸。</p></li><li><p>给你一个圆和一个矩形，怎么判断两个面积是否有相交（包含或简单相交）（一个平面）<br> 首先分别判断矩形四条线段与圆的位置关系，如果所有线段均在圆内部，那么矩形完全包含在圆内部，如果存在某条线段与圆相交，那么矩形与圆部分相交，如果线段均在圆外，那么判断圆心是否在矩形内，在的话圆完全包含在矩形内，否则圆与矩形不相交。</p></li><li><p>如何对球体和长方体进行碰撞检测？<br> 计算球心到每一个面和顶点的距离，如果任何一个距离大于球半径且球心不在长方体内则不相交，否则有交点。</p></li><li><p>如何求正交矩阵的逆<br> 求正交矩阵的转置矩阵即可。</p></li><li><p>为什么要用齐次坐标系、</p><ul><li>能够用来区分向量和点（向量最后一个为0，点最后一个为1）</li><li>方便进行平移变换（否则要相加，用齐次坐标系相乘即可）</li><li>支持投影矩阵</li></ul></li><li><p>如何判断空间中的一个点在空间三维物体内？</p><ul><li>从该点出发,作任意方向的一根射线</li><li>考察此射线与三维物体各面的交点数,</li><li>如果总数=0或偶数,则在三维物体之外,</li><li>如果总数为奇,则在三维物体之内.</li></ul></li></ol><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><ol><li>有哪些视图变换？<ul><li>模型变换：用于组织各个独立的物体形成一个完整的场景。利用旋转、平移和缩放。</li><li>摄像机变换、视图变换：得到物体与摄像机的相对位置。</li><li>投影变换：将三维物体投影至二维平面上。</li><li>视口变换：将处于标准平面映射到屏幕分辨率范围之内。</li></ul></li></ol><h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><ol><li>什么是光栅化？<br>光栅化负责的是整个渲染过程中的几何成像环节，把几何图元（点、线、面）投影到成像平面，并确定哪些像素或者采样点被图元覆盖。</li><li>直线光栅化算法<ul><li>DDA数值微分算法<br><a href="https://imgtu.com/i/grxBLQ"><img src="https://z3.ax1x.com/2021/05/14/grxBLQ.png" alt="grxBLQ.png"></a></li><li>中点Bresenham算法<br>每次画只会考虑右边或者右上的点两种情况<br><a href="https://imgtu.com/i/grz3lT"><img src="https://z3.ax1x.com/2021/05/14/grz3lT.png" alt="grz3lT.png"></a><br>取这两个橙色方格的中点，如图中圆圈符号所对应的那个点，倘若这个点在直线方程的下面，那么很明显我们应该选择右上的方格。中点位于直线方程的上方，此时选择右边的橙色方格。</li></ul></li><li>为什么会出现锯齿？<br> 因为用有限<strong>离散的像素点去逼近连续的三角形</strong>，这种近似是不准确的。实质上是因为<strong>采样频率过低无法跟上图像的频率</strong>，导致最后结果失真。</li><li>如何抗锯齿<ul><li>超采样反走样（SSAA）<br>将每个像素点进行细分，比如将每个像素点细分成四个采样点，然后对每个采样点进行shading，得到每个采样点的颜色值后，进行求和再平均，得到的颜色值即为该像素点的颜色值。<br>细分采样点越多抗锯齿效果越好，但计算负担也会随之增加。</li><li>多采样反走样（MSAA）<br>将每个像素点进行细分，比如将每个像素点细分成四个采样点，对四个采样点执行三角形覆盖判断并且进行深度测试，然后计算像素中心的颜色并乘以覆盖比例得到最终像素颜色。比如有两个采样点被三角形覆盖且通过了深度测试；就是乘以1/2的比例。<br>这样大大减少了计算量，不必对每个子采样点都进行着色计算。缺点是对于透明测试造成的边缘，MSAA完全没有任何帮助，然后它不能用在延迟渲染中。另外，MSAA相当于默认了采样点的颜色与像素中心差别不大，导致了误差的存在，特别是在纹理映射的时候，如果纹理过大，MSAA可能完全没啥效果</li><li>快速近似反走样（FXAA）<br>就是使用边缘检测滤波器查找边缘，然后将边缘像素用高斯滤波器进行加权混合，达到查找边缘并混合模糊的目的。<br>FXAA的做法性能最好，但FXAA只算一种”虚假“的抗锯齿技术（方法和采样无关），严格来说属于”模糊“锯齿。动态效果通常也不如MSAA。</li><li>时序反走样（TAA）<br>参考文章：</li></ul></li><li>延迟渲染为什么不支持MSAA？<br> 脱离实际的软硬件环境来讲的话，延迟渲染是完全可以支持MSAA的。<br> MSAA每个子Sample都有深度、模板信息，以及用于保存的颜色缓冲和coverage mask。像素点和Sample的位置和深度等数据都是用三角形的三个顶点进行重心插值得到。开启MSAA后，渲染所需的显存数量成倍扩大，对于显卡的显存容量和带宽提出了更高的要求。<br> 对于延迟渲染，因为其几何渲染输出的为光照前数据，Gbuffer中包含诸如法线、金属度、粗糙度等等多种数据，会使用远多于前向渲染的缓冲区，将这些缓冲区全部增大数倍甚至十数倍（如16xMSAA），对GPU显存的开销极大，而且大大增加了深度测试所需读写的数据量，以及PS着色器需要写入的数据量，使得渲染性能也降低。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易图形开发工程师_暑期实习_笔试+面试</title>
      <link href="/zhuylin.github.io/2021/05/10/blog1_wangyimianshi/"/>
      <url>/zhuylin.github.io/2021/05/10/blog1_wangyimianshi/</url>
      
        <content type="html"><![CDATA[<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>笔试基本为模拟题而没有算法题，一共三题，至少要过两题才能过笔试（即要至少AC100%两道题），时间为两个半小时。</p><h3 id="题目1：分组问题"><a href="#题目1：分组问题" class="headerlink" title="题目1：分组问题"></a>题目1：分组问题</h3><p><em><strong>有A、B两个部门，各有6个人（三男三女），输入为每个人的乒乓球能力值，要求B能赢（三局全胜或三局两胜，胜利的一方能力值之和要大于另一方，能力值相同A组赢），输出为B能赢有多少种对打方案（男双、女双、混双）。</strong></em></p><p>一共有81种可能，if判断模拟即可。</p><h3 id="题目2：循环猜拳"><a href="#题目2：循环猜拳" class="headerlink" title="题目2：循环猜拳"></a>题目2：循环猜拳</h3><p><em><strong>有N个人绕成一圈（首尾相接），从中选择一位同学K，与下一人G猜拳（石头剪刀布），如果K赢了G退出，K继续和下一个人猜拳；如果K输了K退出，G和下一人猜拳；如果出的一样打平，则从G开始，G和下一人猜拳。循环往复，如果只剩一人则结束游戏，或者到一定的猜拳次数M结束。</strong></em><br><em><strong>输入为N（人数），M（循环次数），接下来是N个字符，代表每个人出的（S表示石头，C表示剪刀，Y表示布），输出为任意选定一个人开始，在结束后能保留的最大人数。</strong></em></p><p>用到双端队列deque来模拟。</p><h3 id="题目3：礼品数目"><a href="#题目3：礼品数目" class="headerlink" title="题目3：礼品数目"></a>题目3：礼品数目</h3><p><em><strong>题目有点忘记，大概是一个游戏中，有一个排行榜，每次过关的人都会记录上去，排行榜按通过者的通过时间来排名，然后在排行榜中位的会得到礼物，得过的不会重复得到。输入为一系列字符串，形式为“人名 通过时间”， 输出为要准备的礼物数量是多少</strong></em></p><p>用prioity_queue和unordered_map来模拟，最后过了10%，时间到了最后没过这一道题，应该有一些细节没注意。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>2：30分开始，面到了4：30左右。2个小时左右，没有问项目，主要看编程、算法、数据结构、c++（或其他语言，我当时说熟悉的是c++）、操作系统、计算机网络、openGL、图形学</p><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><p>开局代码题，题目挺长，要一定时间理解。<br>输入[20190102, 1, 2]表示在2019年1月2号路人1和1路人2相识，如果路人1和2相识，路人2和3相识，则代表1和3也相识，题目要求求出最早所有人认识的时间。<br>输入大概是：<br>[20190102, 1, 2],<br>[201903201, 2, 3],<br>…<br>[20190231, 3, 6]<br>代码全手撕，其实思路很简单，就是使用并查集，写出find和union，每次union时判断是否已经每个人都结识了，即每个人的祖先结点都是同一个，如果是则输出改时间点即可。当时可能union写错还是什么编译没成功，但是面试官说思路对了。</p><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><ol><li>给K个有序数组，然后合成一个有序数组（最大的数组元素个数为n）<br>先回答了用堆，但是复杂度是O(nlogn)，后面面试官问有什么更好的方法，我说了K个指针，面试官说好像复杂度还是一样，有没有更好的方法，然后终于想到了用归并，但是说错了复杂度，经面试官提醒，说了正确的O(nlogK)</li><li>判断连续最长的合法括号长度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; <span class="number">1</span></span><br><span class="line">&#123;&#123;&#125;&#125; <span class="number">1</span></span><br><span class="line">&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#123;&#123;&#123;&#123;&#125;&#125;&#125;&#125;&#125;&#125;&#125; <span class="number">3</span></span><br></pre></td></tr></table></figure>当时思路不正确（用了动态规划），想不出，面试官说回去想想怎么做，提醒用左右指针、滑动窗口</li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li>   快排是稳定的吗？举例说明<br>知道是不稳定的，但是举的例子没对，面试官说了是比如像 1235744444421这样子的，以中间的4的pivot（这里开始感觉怎么自己都没一个答得十分对的，感觉有点慌，但是后面终于到基础一些的了）</li></ol><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ol><li>   虚函数怎么实现？<br>这里面试官说我答得不错嘿嘿（答了作用、虚表、虚指针、怎么改变虚表、怎么调用虚函数等）</li><li>   虚函数的继承</li><li>   构造函数的调用顺序</li><li>   析构函数的调用顺序</li><li>   为什么析构函数要用虚函数</li><li>面试官手写了一个代码，问输出，大概如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; “A…”;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="built_in">B</span>() &#123;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; “B…”;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 其实有基于前几个个问题的，答案是”A…B…”，有构造函数顺序，而且A表创建B表才创建，创建A时B还没创建就还没有虚函数表实现B的重写func()</li><li>   STL的容器如何使用内存<br>答了2倍增长、复制、销毁这些，后面问有没有更快的方法（大概是）？当时答右值引用，说不对，后面说先resize什么的</li><li>   resize()和reserve()区别</li><li>   push_back()和emplace_back()区别<br>针对之前说的右值引用的细问，不过还好常用emplac_back哈哈，最后他也问我是不是常用emplace_back，其实之前敲的代码也是用这个。</li><li>   有些问题会细问一些小问题，忘记了。。。</li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>   进程之间怎么实现互斥<br>答了信号量、临界区、管程、Peterson算法，但是他问还有什么，一时不知道了，他后面又说了一个。</li><li>   说一下进程与线程<br>先回答什么是进程，什么是线程，然后说区别联系</li><li>   用过多线程吗<br>说无，然后就没问了</li></ol><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ol><li>   说一下计算机网络的三次握手和四次挥手<br>但是说我答得不错嘿嘿（四次挥手还答了第二步后客户端不能发但能接、最后一次有2MSL这些，建议答得详细一点）</li><li>   说一下拥塞控制算法<br>当时没准备这个，只能按考研时候记下来的，也有一年左右了，说了指数增长、阈值后线性增1这些，没答好</li></ol><h3 id="openGL"><a href="#openGL" class="headerlink" title="openGL"></a>openGL</h3><ol><li>   openGL渲染管线<br>常见问题了，以前的经验贴基本也说有，背就完事（顶点着色器、图元装配阶段、曲面细分阶段、几何着色器、光栅化、片段着色器、像素操作，参考计算机图形学编程baceC++这本书的）</li><li>   vs（顶着）到fs（片着）如何转换数据，就是怎么顶点变到像素<br>当时先答了光栅化阶段判断在不在三角形内，然后blabla，说到了用三个顶点的重心坐标插值这个关键字面试官就说可以了，答到这个关键字基本差不多了</li></ol><h3 id="图形学（或数学？）"><a href="#图形学（或数学？）" class="headerlink" title="图形学（或数学？）"></a>图形学（或数学？）</h3><ol><li>   三维坐标下，给出入射向量和法线，求反射向量<br>说了openGL的reflect()函数，面试官要推导出，API带的函数性能不行，知道用点积，但是最后没写对，最后面试官说下去想想，用点积和两倍什么。</li></ol><h3 id="反问环节"><a href="#反问环节" class="headerlink" title="反问环节"></a>反问环节</h3><ol><li>   问了进去实习做什么工作</li><li>   没时间了就不问了，毕竟比原计划多了半个小时</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实有很多小问题忘记了，因为是一两句话回答的事，总之给我的感觉是：首先编程题要积累，当时华为就是有道机试题是考并查集，当时都不懂怎么做结束后就去leetcode看，这次用上了，虽然还是出了问题orz；然后基础理论一定要牢固，然后要有一定的思考推断能力，当然当时没想出怎么做至少不要先放弃，多想想，没想出也没关系，至少面试官觉得你是会去努力思考就行。面试官听nice滴。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
